/**
 * 
 */
package com.lcpoletto.tasks.model;

import java.io.Serializable;
import java.util.Date;

import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAutoGeneratedKey;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBHashKey;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBIgnore;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBTable;
import com.lcpoletto.exceptions.ValidationException;

/**
 * This class represent one task to be persisted on AWS DynamoDB table.
 * 
 * @author Luis Carlos Poletto
 */
@DynamoDBTable(tableName = "tasks")
public class Task implements Serializable, Comparable<Task> {

    private static final long serialVersionUID = 9210143191071191081L;

    /**
     * Even though this property is not part of the json schema I don't have
     * enough knowledge on how to update a task without having a way to uniquely
     * identify it.
     */
    @DynamoDBHashKey
    @DynamoDBAutoGeneratedKey
    private String id;
    private String user;
    private String description;
    private Integer priority;
    private Date completed;

    /**
     * This is used for the enable the api gateway to return the generated
     * location back when creating a new resource.
     */
    @DynamoDBIgnore
    private String resourceUri;

    /**
     * Overriding default toString for logging purposes, using a json-like
     * representation.
     */
    @Override
    public String toString() {
        final StringBuilder result = new StringBuilder();
        result.append("{ \"id\": \"");
        result.append(id);
        result.append("\", \"user\": \"");
        result.append(user);
        result.append("\", \"description\": \"");
        result.append(description);
        result.append("\", \"priority\": ");
        result.append(priority);
        result.append(", \"completed\": \"");
        result.append(completed);
        result.append("\", \"resourceUri\": \"");
        result.append(resourceUri);
        result.append("\" }");
        return result.toString();
    }

    /**
     * Compares two tasks based on the following rule: first by the completed
     * date (descending) and secondly by the priority (ascending). If a task has
     * not been completed it should go before all other tasks.
     */
    @Override
    public int compareTo(Task o) {
        if (completed == null) {
            if (o.completed == null) {
                return priority.compareTo(o.priority);
            }
            // other is completed, this should come first
            return -1;
        }
        // this is completed
        if (o.completed == null) {
            // other is not completed, thus it should come first
            return 1;
        }

        // both are completed
        final int dateComparison = completed.compareTo(o.completed);
        if (dateComparison == 0) {
            // if they were completed at the same millisecond, priority is the
            // tie breaker
            return priority.compareTo(o.priority);
        }
        return -dateComparison;
    }

    /**
     * Validator method, this should probably be handled by Bean Validation JSR,
     * but I think by doing so it could defeat the purpose of smaller programs
     * running on lambdas.
     * 
     * @param update
     *            <code>true</code> if the action is an update
     */
    public void validate(final boolean update) {
        // insert
        if (description == null || description.isEmpty()) {
            throw new ValidationException("Task description is required.");
        }
        if (priority == null || priority < 0 || priority > 9) {
            throw new ValidationException("Task priority is required and must be between 0 and 9.");
        }

        if (update) {
            if (id == null || id.isEmpty()) {
                throw new ValidationException("Task id is required.");
            }
        }
    }

    /**
     * Getter for user.
     *
     * @return the user
     */
    public String getUser() {
        return user;
    }

    /**
     * Setter for user.
     *
     * @param user
     *            the user to set
     */
    public void setUser(String user) {
        this.user = user;
    }

    /**
     * Getter for description.
     *
     * @return the description
     */
    public String getDescription() {
        return description;
    }

    /**
     * Setter for description.
     *
     * @param description
     *            the description to set
     */
    public void setDescription(String description) {
        this.description = description;
    }

    /**
     * Getter for priority.
     *
     * @return the priority
     */
    public Integer getPriority() {
        return priority;
    }

    /**
     * Setter for priority.
     *
     * @param priority
     *            the priority to set
     */
    public void setPriority(Integer priority) {
        this.priority = priority;
    }

    /**
     * Getter for id.
     *
     * @return the id
     */
    public String getId() {
        return id;
    }

    /**
     * Setter for id.
     *
     * @param id
     *            the id to set
     */
    public void setId(String id) {
        this.id = id;
    }

    /**
     * Getter for completed.
     *
     * @return the completed
     */
    public Date getCompleted() {
        return completed;
    }

    /**
     * Setter for completed.
     *
     * @param completed
     *            the completed to set
     */
    public void setCompleted(Date completed) {
        this.completed = completed;
    }

    /**
     * Getter for resourceUri.
     *
     * @return the resourceUri
     */
    public String getResourceUri() {
        return resourceUri;
    }

    /**
     * Setter for resourceUri.
     *
     * @param resourceUri
     *            the resourceUri to set
     */
    public void setResourceUri(String resourceUri) {
        this.resourceUri = resourceUri;
    }
}