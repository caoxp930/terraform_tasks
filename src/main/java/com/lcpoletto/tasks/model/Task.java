/**
 * 
 */
package com.lcpoletto.tasks.model;

import java.io.Serializable;
import java.util.Date;

import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAutoGeneratedKey;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBHashKey;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBTable;

/**
 * This class represent one task to be persisted on AWS DynamoDB table.
 * 
 * @author Luis Carlos Poletto
 */
// https://aws.amazon.com/blogs/compute/how-to-remove-boilerplate-validation-logic-in-your-rest-apis-with-amazon-api-gateway-request-validation/
// TODO: maybe use autovalue?
// https://github.com/google/auto/blob/master/value/userguide/index.md
@DynamoDBTable(tableName = "tasks")
public class Task implements Serializable, Comparable<Task> {

    private static final long serialVersionUID = 9210143191071191081L;

    /**
     * Even though this property is not part of the json schema I don't have
     * enough knowledge on how to update a task without having a way to uniquely
     * identify it.
     */
    @DynamoDBHashKey
    @DynamoDBAutoGeneratedKey
    private String id;
    private String user;
    private String description;
    private Integer priority;
    // TODO: Need to figure out how to send this back to the user as UTC date
    // instead of milliseconds
    private Date completed;

    /**
     * Overriding default toString for logging purposes, using a json-like
     * representation.
     */
    @Override
    public String toString() {
        final StringBuilder result = new StringBuilder();
        result.append("{ \"id\": \"");
        result.append(id);
        result.append("\", \"user\": \"");
        result.append(user);
        result.append("\", \"description\": \"");
        result.append(description);
        result.append("\", \"priority\": ");
        result.append(priority);
        result.append(", \"completed\": \"");
        result.append(completed);
        result.append("\" }");
        return result.toString();
    }

    /**
     * Compares two tasks based on the following rule: first by the completed
     * date (descending) and secondly by the priority (ascending). If a task has
     * not been completed it should go before all other tasks.
     */
    @Override
    public int compareTo(Task o) {
        if (completed == null) {
            if (o.completed == null) {
                return priority.compareTo(o.priority);
            }
            // other is completed, this should come first
            return -1;
        }
        // this is completed
        if (o.completed == null) {
            // other is not completed, thus it should come first
            return 1;
        }

        // both are completed
        final int dateComparison = completed.compareTo(o.completed);
        if (dateComparison == 0) {
            // if they were completed at the same millisecond, priority is the
            // tie breaker
            return priority.compareTo(o.priority);
        }
        return -dateComparison;
    }

    /**
     * Getter for user.
     *
     * @return the user
     */
    public String getUser() {
        return user;
    }

    /**
     * Setter for user.
     *
     * @param user
     *            the user to set
     */
    public void setUser(String user) {
        this.user = user;
    }

    /**
     * Getter for description.
     *
     * @return the description
     */
    public String getDescription() {
        return description;
    }

    /**
     * Setter for description.
     *
     * @param description
     *            the description to set
     */
    public void setDescription(String description) {
        this.description = description;
    }

    /**
     * Getter for priority.
     *
     * @return the priority
     */
    public Integer getPriority() {
        return priority;
    }

    /**
     * Setter for priority.
     *
     * @param priority
     *            the priority to set
     */
    public void setPriority(Integer priority) {
        this.priority = priority;
    }

    /**
     * Getter for id.
     *
     * @return the id
     */
    public String getId() {
        return id;
    }

    /**
     * Setter for id.
     *
     * @param id
     *            the id to set
     */
    public void setId(String id) {
        this.id = id;
    }

    /**
     * Getter for completed.
     *
     * @return the completed
     */
    public Date getCompleted() {
        return completed;
    }

    /**
     * Setter for completed.
     *
     * @param completed
     *            the completed to set
     */
    public void setCompleted(Date completed) {
        this.completed = completed;
    }
}